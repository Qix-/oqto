/**
 * OQTO CASCADING CONFIGURATION SHEET
 *         PEG.JS GRAMMAR
 */

{
	// @include functions.js
}

start
	= document:(_? statement:statement _? {return statement})*
		{
			var doc = [];
			for (var i = 0, len = document.length; i < len; i++)
				if (document[i] != undefined)
					doc.push(document[i]);
			return doc;
		}
	;

/****************************************
 * INCLUSIONS
 ***************************************/
// @include ./tokens.peg

/****************************************
 * STATEMENTS
 ***************************************/
statement
	= comment
	/ directive:statement_directive
		{ return {type: 'directive', directive: directive} }
	;

statement_directive "directive"
	= '@' directive:directive _? ';'
		{ return directive }

/****************************************
 * RULE
 ***************************************/
rule_multiple
	= first:rule_single
	  other:(_? ',' _? rule:rule_single {return rule;})*
	  	{
	  		if ($U(typeof other))
	  			return [first].concat(other);
	  		return [first];
	  	}

rule_single
	= first:selector other:(_ selector)*
		{
			if ($U(typeof other))
				return [first].concat(other);
			return [first];
		}
	;

/****************************************
 * DIRECTIVES
 ***************************************/
directive
	= directive_use
	/ directive_import
	/ directive_vendor
	;

directive_use "directive: use"
	= 'use' _ module:value name:(_ 'as' _ name:value {return name})?
		{ return {name: module, alias: ($U(typeof name) ? name : null)} }

directive_import "directive: import"
	= 'import' _ imp:value
		{ return {imp: imp} }

directive_vendor "directive: vendor"
	= 'vendor' _ prefix:value name:(_ 'as' _ name:value {return name})?
		{ return {prefix: prefix, alias: ($U(typeof name) ? name : null)} }

/****************************************
 * SELECTOR IDENTIFIER RULES
 ***************************************/
selector
	= selector_env selector_env_args?
	/ selector_task
	/ selector_class
	/ selector_glob
	;

selector_env "selector: environment"
	= '@' environment_token
	;

selector_env_args "environment selector arguments"
	= '(' _? value (_ value)* _? ')'
	;

selector_task "selector: task"
	= '#' basic_identifier
	;

selector_class "selector: class"
	= '.' basic_identifier
	;

selector_glob "selector: glob"
	= double_string
	;

selector_config "selector: config"
	= '$' basic_identifier attr_operator value
	;

/****************************************
 * ATTRIBUTE OPERATORS
 ***************************************/
attr_operator "attribute operator"
	= not:'!'? op:attr_operator_basic
		{
			if ($U(typeof not))
				return operator_not(op);
			else
				return op;
		}

attr_operator_basic "basic attribute operator"
	= '='
		{ return operator_eq; }
	/ '*='
		{ return operator_contains; }
	/ '~='
		{ return operator_inlist; }
	/ '^='
		{ return operator_begins; }
	/ '$='
		{ return operator_ends; }
	;

/****************************************
 * BASIC RULES
 ***************************************/
value_list "value list"
	= init:value subs:(_ val:value {return val})*
		{return [init].concat(subs)}
	;

value "value"
	= string
	/ digits:$([0-9]+)
		{return parseInt(digits)}
	/ ('true' / 'yes' / 'on')
		{return true}
	/ ('false' / 'no' / 'off')
		{return false}
	/ $([a-z\-_]i [a-z0-9\-_]i* &[^a-z\-_0-9]i)
	;

basic_identifier "identifier"
	= $([a-z\-\_]i [a-z\-_0-9]i*)
	;

string "string"
	= double_string
	/ single_string
	;

single_string "single quoted string"
	= '\'' string:$(escape_sequence / [^'])* '\''
		{return string}
	;

double_string "double quoted string"
	= '"' string:$(escape_sequence / [^"])* '"'
		{return string}
	;
	
escape_sequence "escape sequence"
	= '\\' escape:escape
		{return escape}
	;

escape "escape code"
	= '"'
	/ '\''
	/ '\\'
	/ '/'
	/ 'b' { '\b' }
	/ 'f' { '\f' }
	/ 'n' { '\n' }
	/ 'r' { '\r' }
	/ 't' { '\t' }
	/ 'e' { '\x1b' }
	/ 'u' digits:$(hex_digit hex_digit hex_digit hex_digit)
		{return String.fromCharCode(parseInt(digits, 16))}
	/ 'x' digits:$(hex_digit hex_digit)
		{return String.fromCharCode(parseInt(digits, 16)) }
	/ digits:$(octal_digit octal_digit octal_digit)
		{return String.fromCharCode(parseInt(digits, 8)) }
	;

octal_digit "octal digit"
	= [0-8]
	;

hex_digit "hexadecimal digit"
	= [a-f0-9]i
	;

comment "comment"
	= '/*' (!'*/' .)+ '*/'
		{}
	;

_ "whitespace"
	= ([ \r\n\f\t])+
		{}
	;