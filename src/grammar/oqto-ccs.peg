/**
 * OQTO CASCADING CONFIGURATION SHEET
 *         PEG.JS GRAMMAR
 */

{
	// @include functions.js
}

start
	= document:(_? statement:statement _? {return statement})*
		{
			var doc = [];
			for (var i = 0, len = document.length; i < len; i++)
				if (document[i] != undefined)
					doc.push(document[i]);
			return doc;
		}
	;

/****************************************
 * STATEMENTS
 ***************************************/
statement
	= comment
	/ directive:statement_directive
		{return {type: 'directive', directive: directive}}
	;

statement_directive
	= '@' directive:directive _? ';'
		{return directive}

/****************************************
 * RULES
 ***************************************/
rule_node
	= 


/****************************************
 * CONDITIONALS
 ***************************************/
conditional_multiple
	= first:conditional_single
	  other:(_? ',' _? rule:conditional_single {return rule;})*
	  	{
	  		if ($U(typeof other))
	  			return [first].concat(other);
	  		return [first];
	  	}

conditional_single
	= first:selector other:(_ selector)*
		{
			if ($U(typeof other))
				return [first].concat(other);
			return [first];
		}
	;

/****************************************
 * DIRECTIVES
 ***************************************/
directive
	= directive_use
	/ directive_import
	/ directive_vendor
	;

directive_use
	= 'use' _ module:value name:(_ 'as' _ name:value {return name})?
		{return {name: module, alias: ($U(typeof name) ? name : null)}}

directive_import
	= 'import' _ imp:value
		{return {imp: imp}}

directive_vendor
	= 'vendor' _ prefix:value name:(_ 'as' _ name:value {return name})?
		{return {prefix: prefix, alias: ($U(typeof name) ? name : null)}}

/****************************************
 * SELECTOR IDENTIFIER RULES
 ***************************************/
selector
	= selector_env selector_env_args?
	/ selector_task
	/ selector_class
	/ selector_glob
	/ selector_config
	/ selector_task_result
	;

selector_env
	= '@' selector_env_token
	;

selector_env_token
	= 'arch'		/* arch */
	/ 'os'			/* platform */
	/ 'system'		/* type */
	/ 'release'		/* release */
	;

selector_env_args
	= '(' _? value (_ value)* _? ')'
	;

selector_task
	= '#' basic_identifier
	;

selector_class
	= '.' basic_identifier
	;

selector_glob
	= double_string
	;

selector_config
	= '$' basic_identifier attr_operator value
	;

selector_task_result
	= '[' basic_identifier ']'
	;

/****************************************
 * ATTRIBUTE OPERATORS
 ***************************************/
attr_operator
	= not:'!'? op:attr_operator_basic
		{
			if ($U(typeof not))
				return operator_not(op);
			else
				return op;
		}

attr_operator_basic
	= '='
		{return operator_eq}
	/ '*='
		{return operator_contains}
	/ '~='
		{return operator_inlist}
	/ '^='
		{return operator_begins}
	/ '$='
		{return operator_ends}
	;

/****************************************
 * BASIC RULES
 ***************************************/
value_list
	= init:value subs:(_ val:value {return val})*
		{return [init].concat(subs)}
	;

value
	= string
	/ digits:$([0-9]+)
		{return parseInt(digits)}
	/ ('true' / 'yes' / 'on')
		{return true}
	/ ('false' / 'no' / 'off')
		{return false}
	/ $([a-z\-_]i [a-z0-9\-_]i* &[^a-z\-_0-9]i)
	;

basic_identifier
	= $([a-z\-\_]i [a-z\-_0-9]i*)
	;

string
	= double_string
	/ single_string
	;

single_string
	= '\'' string:$(escape_sequence / [^'])* '\''
		{return string}
	;

double_string
	= '"' string:$(escape_sequence / [^"])* '"'
		{return string}
	;
	
escape_sequence
	= '\\' escape:escape
		{return escape}
	;

escape
	= '"'
	/ '\''
	/ '\\'
	/ '/'
	/ 'b' { '\b' }
	/ 'f' { '\f' }
	/ 'n' { '\n' }
	/ 'r' { '\r' }
	/ 't' { '\t' }
	/ 'e' { '\x1b' }
	/ 'u' digits:$(hex_digit hex_digit hex_digit hex_digit)
		{return charCode(digits, 16)}
	/ 'x' digits:$(hex_digit hex_digit)
		{return charCode(digits, 16)}
	/ digits:$(octal_digit octal_digit octal_digit)
		{return charCode(digits, 8)}
	;

octal_digit
	= [0-8]
	;

hex_digit
	= [a-f0-9]i
	;

comment
	= '/*' (!'*/' .)+ '*/'
		{}
	;

_
	= ([ \r\n\f\t])+
		{}
	;